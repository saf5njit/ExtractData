# Author: Santiago A. Flores Roman
# Description: This script extracts the requested data from the data files generated by RASPA.
# Requirements: Numpy, Pandas and matplotlib have to be installed.
# Instructions: 
#   This script assumes that there is only one data file per Output/System_#/ directory. The reason
#   is that several points can be run at the same time in Slurm, acceleating the simulation. If there
#   are several data files in one directory, then RASPA will have simulated point by point, which is 
#   slow as the program is not parallelized.
#   Run the script as following for more information.
#   python3 extractRaspaData.py -h 

import os,re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sys import argv,exit
##########################################################################################################
class Extract():
    def __init__(self,argv):
        self.argv = argv
        self.motor = 'Raspa'
        self.path = './Outputs/System_0/'
        self.dimensions = ['x','y','z']
        self.varsToExtract = ['Rho','P']
        self.outFile = ('outData.dat',False)
        self.sort = 'P'
        self.printInputParams = self.createFigures = False
        self.fileLines = 0
        self.fileName = ''
        self.dimLetter = ''
        self.listInFiles = []
        self.fileNumber = 0
        self.outFilePath = []

    def Flags(self):
        argv = self.argv
        printInputParams = self.printInputParams
        createFigures = self.createFigures
        path = self.path
        units = self.units
        sort = self.sort
        outFile = self.outFile
        dimensions = self.dimensions
        components = self.components
        varsToExtract = self.varsToExtract
        sections = self.sections
        motor = self.motor
        for i in range(len(argv)):
            argv[i] = argv[i].lower()
            if (argv[i] == '-h'): self.Help()
            elif (argv[i] == '-p'): printInputParams = True
            elif (argv[i] == '-f'): createFigures = True
            elif (argv[i] == '-i'): path = argv[i+1]
            elif (argv[i] == '-u'): units = argv[i+1]
            elif (argv[i] == '-s'): sort = argv[i+1]
            elif (argv[i] == '-o'): outFile = (argv[i+1],True)
            elif (argv[i] == '-m'): motor = argv[i+1]
            elif (argv[i] == '-d'): 
                dimensions = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    dimensions.append(argv[j])
            elif (argv[i] == '-c'): 
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    components.append(argv[j])
            elif (argv[i] == '-v'): 
                varsToExtract = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    varsToExtract.append(argv[j])
            elif (argv[i] == '-t'): 
                sections = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    sections.append(argv[j])
        if not re.search('-c',' '.join(argv).lower()):
            print('Error: List of components was not given.\nPrinting help.')
            self.Help(); sys.exit(1)
        self.printInputParams = printInputParams
        self.createFigures = createFigures
        self.path = path
        self.units = units
        self.sort = sort
        self.outFile = outFile
        self.dimensions = dimensions
        self.components = components
        self.varsToExtract = varsToExtract
        self.sections = sections

    def ReadInputFiles(self):
        path = self.path
        listInFiles = os.listdir(path)
        self.listInFiles = listInFiles

    def CreateDataFrame(self,outData):
        dimensions = self.dimensions
        sort = self.sort
        keys = list(outData.keys())
        longestKey = keys[0]
        for i in range(1,len(keys)): # Use a python's library!
            if (len(outData[keys[i]]) > len(outData[keys[i-1]])): longestKey = keys[i]
        outData = pd.DataFrame(outData,index=range(len(outData[longestKey])))
        for key in outData.columns:
            findSortKey = re.search(f'^{sort}\[.+',key)
            if findSortKey: 
                outData.sort_values(findSortKey.group(),ignore_index=True,inplace=True); break
        return outData

    def CreateOutFile(self,outData,fileNumber):
        outPath, outFileName, outExtension = self.outFilePath
        if outPath: outPath = f'{outPath}dataFiles/' #If output file is in a subdirectory.
        else: outPath = 'dataFiles/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        outData.to_csv(f'{outPath}{fileNumber}_{outFileName}{outExtension}',sep='\t',index=False,na_rep='NaN')

    def ReadOutputFile(self):
        outFile = self.outFile
        outFilePath = re.search(r'^(.+/)?(.+)(\..+)$',outFile[0])
        if not outFilePath.group(3): 
            outFilePath = (outFilePath.group(1),outFilePath.group(2),'.dat')
        else: 
            outFilePath = outFilePath.group(1,2,3)
        self.outFilePath = outFilePath
        return outFilePath

    def PlotVariables(self,outData,fileNumber):
        outPath,outFileName,outExtension = self.outFilePath
        outData.plot(style='.',subplots=True,grid=True,xlabel='Number of cycles')
        plt.tight_layout()
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        plt.savefig(f'{outPath}{fileNumber}_{outFileName}.pdf')

    def ExtractData(self):
        listInFiles = self.listInFiles
        path = self.path
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        for i in range(len(listInFiles)):
            print('\nExtracting data...')
            with open(path+listInFiles[i],'r') as fileContent: inFileLines = fileContent.readlines()
            outData = self.CallExtractors(listInFiles[i],inFileLines) # From derived class.
            print('\nOrganizing data...')
            outData = self.CreateDataFrame(outData)
            print(outData)
            print(outData.describe())
            if createOutFile:
                outPath, outFileName, outExtension = self.ReadOutputFile()
                print(f'\nCreating output file: {outPath}dataFiles/{i}_{outFileName}{outExtension} ...')
                self.CreateOutFile(outData,i)
                if createFigures: 
                    print('\nCreating figures...')
                    self.PlotVariables(outData,i)
            else:
                if createFigures: 
                    _ = self.ReadOutputFile(outFile)
                    print('\nCreating figures...')
                    self.PlotVariables(outData)
            print(f'\nNormal termination for file {listInFiles[i]}')
        print(f'\nNormal termination.')
        exit(0)

class Raspa(Extract):
    def __init__(self): 
        Extract.__init__(self,argv)
        self.components = []
        self.units = 'kPa'
        self.sections = ['prod']

    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        components = self.components
        units = self.units
        sections = self.sections
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tFluid components: {components}')
        print(f'\tPressure unit: {units}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        for i in range(len(listInFiles)):
            print(f'\tInput file:')
            print(f'\t\t{listInFiles[i]}')
            if createOutFile: print(f'\tOutput file: {i}_{outFileName}')

    def CallExtractors(self,fileName,fileLines):
        varsToExtract = self.varsToExtract
        components = self.components
        dimensions = self.dimensions
        units = self.units
        sections = self.sections
        outData = {}
        if ('V' in varsToExtract): outData['V[A^3]'] = self.ExtractVolumes(fileLines)
        if ('T' in varsToExtract): outData['T[K]'] = self.ExtractTemperatures(fileName,fileLines)
        if ('P' in varsToExtract): outData[f'P[{units}]'] = self.ExtractPressures(fileName,fileLines)
        if ('U' in varsToExtract): outData['U[K]'] = self.ExtractInternalEnergy(fileLines)
        if ('Mu' in varsToExtract): 
            for comp in components:
                chemPots,deltaChemPots = self.ExtractWidomChemicalPotential(fileLines,comp)
                outData['Mu[K]'+f' {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData['deltaMu[K]'+f' {comp}'] = deltaChemPots
        if ('IdMu' in varsToExtract): 
            for comp in components:
                chemPots,deltaChemPots = self.ExtractIdealWidomChemicalPotential(fileLines,comp)
                outData['IdMu[K]'+f' {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData['deltaIdMu[K]'+f' {comp}'] = deltaChemPots
        if ('ExMu' in varsToExtract): 
            for comp in components:
                chemPots,deltaChemPots = self,ExtractExcessWidomChemicalPotential(fileLines,comp)
                outData['ExMu[K]'+f' {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData['deltaExMu[K]'+f' {comp}'] = deltaChemPots
        if ('Rho' in varsToExtract): 
            for comp in components:
                outData['Rho[kg/m^3]'+f' {comp}'] = self.ExtractDensities(fileLines,comp)
        if ('N' in varsToExtract): 
            for comp in components:
                outData['N'+f' {comp}'] = self.ExtractNumberOfMolecules(fileLines,comp)
        if ('L' in varsToExtract): 
            for dim in dimensions:
                outData['Box-L[A]'+f' {dim}'] = self.ExtractBoxLengths(fileLines,dim)
        return outData

    def ExtractVolumes(self,fileLines):
        sections = self.sections
        volumes = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findVolume = re.search(r'^Volume:\s+(\d+\.?\d*)\s+\[A\^3\]$',fileLines[line])
                    if findVolume: volumes.append(float(findVolume.group(1))) #A^3
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findVolume = re.search(r'Volume:\s+(\d+\.?\d*).+Average\s+Volume:',fileLines[line])
                    if findVolume: volumes.append(float(findVolume.group(1))) #A^3
        return pd.Series(volumes,index=range(len(volumes)))

    def ExtractPressures(self,fileName,fileLines):
        units = self.units
        sections = self.sections
        pressures = []
        for sec in sections:
            if (sec.lower() == 'init'): print('Warning: Pressure is not calculated by RASPA during initialization and equilibration cycles.')
            else:
                for line in range(len(fileLines)):
                    findPressure = re.search(f'Average pressure:.+?(\d+\.\d*)\s+\[{units}\]',fileLines[line])
                    if (findPressure and float(findPressure.group(1)) != 0.0): pressures.append(float(findPressure.group(1)))
        if (len(pressures) == 0):
            print('No molecular pressures were found. Extracting fixed external pressure.')
            findPressure = re.search(f'.+_(\d+\.?\d*e?\+?\d*)\.data',fileName)
            if unit == 'bar': pressures.append(float(findPressure.group(1))*1e-5)
            elif unit == 'atm': pressures.append(float(findPressure.group(1))*9.896e-6)
            else: pressures.append(float(findPressure.group(1))*1e-3) #kPa
        return pd.Series(pressures,index=range(len(pressures)))

    def ExtractTemperatures(self,fileName,fileLines):
        sections = self.sections
        temperatures = []
        for sec in sections:
            if (sec.lower() == 'init'):
                print('Warning: Temperature is not calculated by RASPA during initialization cycles.')
                for line in range(len(fileLines)):
                    findTemperature = re.search(f'^Temperature:\s+(\d+\.?\d*)$',fileLines[line])
                    if findTemperature: temperatures.append(float(findTemperature.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findTemperature = re.search(f'Temperature:\s+(\d+\.?\d*).+Translational',fileLines[line])
                    if findTemperature: temperatures.append(float(findTemperature.group(1)))
            if (len(temperatures) == 0):
                print('No molecular temperatures were found. Extracting fixed external temperatures.')
                temperatures.append(float(re.search('.+_(\d+\.?\d*)_\d+\.?\d*e?\+?\d*\.data',fileName).group(1)))
        return pd.Series(temperatures,index=range(len(temperatures)))

    def ExtractInternalEnergy(self,fileLines):
        sections = self.sections
        energies,deltaEnergies = [],[]
        for sec in sections:
            if (sec.lower() == 'init'):
                print('Warning: Internal energy is not calculated by RASPA during initialization, equilibration and production cycles.')
                print('Conserved energy will be extracted. It is calculated after initialization cycles (from equilibration and production cycles).')
                for line in range(len(fileLines)):
                    findEnergy = re.search(f'^Conserved\senergy:\s+(-?\d+\.?\d*)',fileLines[line])
                    if findEnergy: energies.append(float(findEnergy.group(1)))
                if (len(energies) == 0):
                    print('Warning: There was no conserved energy to extract. Extracting current energies per cycle.')
                    currentEnergies = []
                    for line in range(len(fileLines)):
                        currentEnergy = re.search(f'Current.+energy:\s+(-?\d+\.?\d*)',fileLines[line])
                        lastCurrentEnergy = re.search(f'Current Adsorbate-Cation energy:\s+(-?\d+\.?\d*)',fileLines[line])
                        if lastCurrentEnergy: 
                            currentEnergies.append(float(lastCurrentEnergy.group(1)))
                            energies.append(sum(currentEnergies))
                            currentEnergies = []
                        elif currentEnergy: currentEnergies.append(float(currentEnergy.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findEnergy = re.search(f'Total energy:',fileLines[line])
                    if findEnergy:
                        energy = re.search(f'Average\s+(-?\d+\.\d+).+?(\d+\.\d+)',fileLines[line+8])
                        energies.append(float(energy.group(1))) #J/kb
                        deltaEnergies.append(float(energy.group(2))) #J/kb
                        break
                if not findEnergy:
                    print('Error: Tried to read internal energy, but simulation hasn\'t ended properly.')
                    print('Extracting current energies per cycle.')
                    currentEnergies = []
                    for line in range(len(fileLines)):
                        currentEnergy = re.search(f'Current.+energy:\s+(-?\d+\.?\d*).+avg\.',fileLines[line])
                        lastCurrentEnergy = re.search(f'Current Adsorbate-Cation energy:\s+(-?\d+\.?\d*).+avg\.',fileLines[line])
                        if lastCurrentEnergy: 
                            currentEnergies.append(float(lastCurrentEnergy.group(1)))
                            energies.append(sum(currentEnergies))
                            currentEnergies = []
                        elif currentEnergy: currentEnergies.append(float(currentEnergy.group(1)))
        if (len(energies) == 0): 
            print('Warning: No energy was found from RASPA.'); energies.append(np.nan)
        if (len(deltaEnergies) == 0): deltaEnergies.append(np.nan)
        return pd.Series(energies,index=range(len(energies))),pd.Series(deltaEnergies,index=range(len(deltaEnergies)))

    def ExtractDensities(self,fileLines,component):
        sections = self.sections
        densities = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findDensity = re.search(f'Component.+\({component}\).+density:\s+(\d+\.?\d*)\s+\[kg',fileLines[line])
                    if findDensity: densities.append(float(findDensity.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findDensity = re.search(f'Component.+\({component}\).+density:\s+(\d+\.?\d*)\s+\(',fileLines[line])
                    if findDensity: densities.append(float(findDensity.group(1))) #kg/m^3
        return pd.Series(densities,index=range(len(densities)))

    def ExtractBoxLengths(self,fileLines,dimLetter):
        sections = self.sections
        dimension = {'x':1,'y':2,'z':3}
        boxLengths = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findLength = re.search(f'Box-lengths:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+Box-angles',fileLines[line])
                    if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
            if (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findLength = re.search(f'Box-lengths:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*).+Average',fileLines[line])
                    if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
        return pd.Series(boxLengths,index=range(len(boxLengths)))

    def ExtractNumberOfMolecules(self,fileLines,component):
        sections = self.sections
        nMolecules = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findAmountMolecules = re.search(f'Component.+\({component}\).+molecules:\s+(\d+)/\d+/\d+,',fileLines[line])
                    if findAmountMolecules: nMolecules.append(float(findAmountMolecules.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findAmountMolecules = re.search(f'Component.+\({component}\).+molecules:\s+(\d+)/.+\(',fileLines[line])
                    if findAmountMolecules: nMolecules.append(float(findAmountMolecules.group(1)))
        return pd.Series(nMolecules,index=range(len(nMolecules)))

    def ExtractWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search(f'Average Widom chemical potential:',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\]\s+Average.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot: 
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findChemPot = re.search(f'Component\s+\[{component}\].+average chemical potential:\s+(-?\d+\.?\d*)',fileLines[line]) #J/kb
                        if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0): 
            print('Warning: None chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))

    def ExtractIdealWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Ideal-gas Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom Ideal-gas contribution',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\].+Ideal-gas.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot: 
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read ideal-gas chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current ideal-gas chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findWidom = re.search(f'Component \[{component}\] average Widom',fileLines[line])
                        if findWidom:
                            findChemPot = re.search('ideal-gas.+?(-?\d+\.?\d*)',fileLines[line+1]) #J/kb
                            if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0): 
            print('Warning: None ideal-gas chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))

    def ExtractExcessWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Excess Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom excess contribution',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\].+excess chemical.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot: 
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read excess chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current excess chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findWidom = re.search(f'Component \[{component}\] average Widom',fileLines[line])
                        if findWidom:
                            findChemPot = re.search('excess chemical.+?(-?\d+\.?\d*)',fileLines[line+1]) #J/kb
                            if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0): 
            print('Warning: None excess chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))

class Chainbuild(Extract):
    def __init__(self): Extract.__init__(self,argv)
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        sections = self.sections
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        for i in range(len(listInFiles)):
            print(f'\tInput file:')
            print(f'\t\t{listInFiles[i]}')
            if createOutFile: print(f'\tOutput file: {i}_{outFileName}')

    # def CallExtractors(self,fileName,fileLines):
    # def ExtractVolumes(self,fileLines):
    # def ExtractTemperatures(self,fileName,fileLines):
    # def ExtractInternalEnergy(self,fileLines):
    # def ExtractDensities(self,fileLines):
    # def ExtractBoxLengths(self,fileLines,dimLetter):
    # def ExtractNumberOfMolecules(self,fileLines):
    # def ExtractWidomChemicalPotential(self,fileLines):
    # def ExtractIdealWidomChemicalPotential(self,fileLines):
    # def ExtractExcessWidomChemicalPotential(self,fileLines):

def Help(): # Check!
    print('\nDescription:')
    print('\tThis script extracts the output data generated by RASPA (from production cycles on) and prints it on the Terminal')
    print('\t(and/or saves it in an output file). Primarily, it was created to analize a system\'s general behavior, but it can also')
    print('\tbe used to extract data from RASPA\'s outputs in dataframe formats.')
    print('Requirements: Numpy and Pandas libraries must be installed.')
    print('Warning: This script will read only the last data file produced by RASPA in the indicated directory.')
    print('Instructions:')
    print('\tpython3 extractRaspaData.py [-[Flag] [Arguments]] [-[Flag] [Arguments]] ...')
    print('\tFlags allowed:')
    print('\t\t-h or -H: Call for help.')
    print('\t\t-t or -T: The types of cycles to analyze: Production cycles (prod) or initialization cycles (init). By default: prod')
    print('\t\t\tEquilibration cycles (if added), are included in initialization cycles.')
    print('\t\t-s or -S: Sort data frame according to a given value. By default, it\'s pressure (P).')
    print('\t\t\tIt can be sorted according to only one value, which must be one of the variables given after the flag -v (or -V).')
    print('\t\t-f or -F: Plot the evolution of variables along the cycles.')
    print('\t\t\tThe plot file will be outputFile.pdf, where outputFile is indicated by the -o flag.')
    print('\t\t-p or -P: Print input parameters.')
    print('\t\t-i or -I: Indicate the path where the data file is found. By default: Output/System_0')
    print('\t\t-o or -O: Indicate the "path/fileName" where the extracted data will be printed.')
    print('\t\t\tBy default, no file is created.')
    print('\t\t-u or -U: Indicate the units for the pressure (kPa, atm or bar). By default: kPa')
    print('\t\t-c or -C: List of components involved in the simulation (fluid mixture). You must specify the species, even if it was only one')
    print('\t\t-d or -D: List of dimensions to extract the box-lengths. By deafault, the three dimensions.')
    print('\t\t-v or -V: Indicate the list of variables that will be extracted from the RASPA\'s data files (per cycle). By default: Rho and P.')
    print('\tVariables allowed:')
    print('\t\tV: Volume in A^3.')
    print('\t\tT: Temperature in K.')
    print('\t\tP: Pressure in kPa.')
    print('\t\t\tThree different units can be specified: kPa, atm or bar. By default, kPa.')
    print('\t\tU: Internal energy in K (J/kb).')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tMu: Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\t\tRequires the components to be indicated.')
    print('\t\tIdMu: Ideal-gas Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\t\tRequires the components to be indicated.')
    print('\t\tExMu: Excess Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\t\tRequires the components to be indicated.')
    print('\t\tRho: Density in kg/m^3.')
    print('\t\t\tRequires the components to be indicated.')
    print('\t\tL: Box-length in A.')
    print('\t\t\tRequires the dimentions to be indicated (x, y or z).')
    print('\t\tN: Number of molecules/atoms.') 
    print('\t\t\tRequires the components to be indicated.')
    print('Example:')
    print('\tThe following command would extract the volume and internal energy of a methane-benzene binary mixture from Output/System_1,')
    print('\tas well as the pressure (in atm) and the box-length in the x direction.')
    print('\tThe extracted data would be saved in the file excessProps.dat')
    print('\tpython3 extractRaspaData.py -I Outputs/System_1/ -o ./excessProps.dat -t prod -C methane benzene -v U V P L -U atm -d x -p -s P')
    exit(1)

##########################################################################################################
if __name__ == '__main__':
    print('Author: Santiago A. Flores Roman')
    argvString = ' '.join(argv)
    print(f'\nCommand line being executed:\n{argvString}')
    if re.search(r'-h+',argvString.lower()): Help()
    print(f'\nChecking simulation program...')
    extract = 0
    checkMotor = re.search(r'-m\s+(\w+)\s+',argvString.lower())
    if checkMotor:
        motor = checkMotor.group(1)
        if motor == 'raspa': 
            print('RASPA'); extract = Raspa()
        elif motor == 'chainbuild': 
            print('Chainbuild'); extract = Chainbuild()
        else: print(f'Error: Simulation program not known: {motor}. Exiting.'); exit(1)
    else: print('Error: None simulation program found. Exiting.'); exit(1)
    print('\nReading input parameters...')
    extract.Flags()
    print('\nReading input files...')
    extract.ReadInputFiles()
    if extract.printInputParams == True: 
        print('\nInput parameters:\n')
        extract.PrintInputParameters()
    extract.ExtractData()

# EOS
